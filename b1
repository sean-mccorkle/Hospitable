#!/usr/bin/env perl
#
# Options:   -E skip prep_export step (if done already)
#            -s<file>  condor submit filename (defaults to b1.condor)
#            -d<file>  remove drive script name (defaults to b1_remote_driver)
#
#  This creates on the head node
#    1) a tarball of prep files (in the current working directory)
#    2) a remote driver file
#    3) a condor submit file
#
use strict;

use File::Basename;
use File::Path;
our( $opt_E, $opt_s, $opt_d );  
use Getopt::Std;


getopts( "Ed:s:" ) || die "Bad option, only -E recognized\n";

my $remote_driver_file = $opt_d ? $opt_d : "b1_remote_driver";
my $submit_file = $opt_s ? $opt_s : "b1.condor";
my $condor_logfile = "b1.condor.log";
my $condor_output_file = "b1.condor.outfile.txt";
my $condor_error_file = "b1.condor.error.txt";

my $prep_tarball = "prep_xfer.tar.gz";


# @remote_path is list of bin directories on remote

my @remote_path = ( '~/src/bowtie2-2.2.5' );  

#   @export is a list of from/to pairs.
#     "from" is either a single file or directory or a glob
#          ~ stands for home directory on local system
#     "to" is either a single file or possibly dir, may be empty
#          ~ stands for the remote system working directory
#         if not specified, it defaults to "from" if from is a single
#         file, or ~ from is a glob

my @export = (
               [ '~/src/bowtie2-2.2.5' ],
               [ '~/Proj/Brassica_napus/Transcripts/bn_trans*bt2',  '~/db' ] 
             );

prep_exports( @export ) unless ( $opt_E );


open( SUBMIT, ">$submit_file" ) || die "Can't write to $submit_file: $!\n";

write_submit_preamble();

write_remote_driver();


#IMPORT:


#PROC:

#foreach k ( 1 6 )
#    bowtie2 -k $k -p 8 -x bn_trans -1 ../RNAseq/580-1/902298_ACAGTG_L002_R1_001.fastq -2 ../RNAseq/580-1/902298_ACAGTG_L002_R2_001.fastq -S k6test.sam > k6.log 

close( SUBMIT );

#
#  Cleanup:
#
#  rmdir $tempdir
#


print basename( $0 ), " ends.\n";


                                ###############
                                # Subroutines #
                                ###############

#
# Write the common preamble part of the Condor submit file
#
sub  write_submit_preamble
   {
    print SUBMIT "# submit file created by $0 ", `date`, "\n";
    print SUBMIT "#\n";
    print SUBMIT "executable = $remote_driver_file\n";
    print SUBMIT "\n";
    print SUBMIT "log        = $condor_logfile\n";
    print SUBMIT "output     = $condor_output_file\n";
    print SUBMIT "error      = $condor_error_file\n";
    print SUBMIT "\n";

    my $input_file_list = $prep_tarball;  # this will need to have dynamic content

    print SUBMIT "transfer_input_files  = $input_file_list\n";
    print SUBMIT "should_transfer_files = Yes\n";
    print SUBMIT "when_to_transfer_output = ON_EXIT\n";
    print SUBMIT "\n";
    print SUBMIT "queue 1\n";
    print SUBMIT "\n";
   }

#
# Create the remote driver, the script that will be run on the remote
# (execute) node, which will unpack the environment tarball and run the
# actual executable program
#

sub  write_remote_driver
   {
    open( RDRIVER, ">$remote_driver_file" ) || die "Can't write to $remote_driver_file: $!\n";

    print RDRIVER "#!/bin/csh\n";
    print RDRIVER "# remote_driver_file created by $0 ", `data`, "\n"; 
    print RDRIVER "# \n";
    print RDRIVER "\n";
    print RDRIVER "# unpack environment:\n";
    print RDRIVER "\n";
    print RDRIVER "tar zxvf $prep_tarball\n";
    print RDRIVER "\n";
    print RDRIVER "# execute user command\n";
    print RDRIVER "\n";
    print RDRIVER "ls -lR\n";
    print RDRIVER "echo bye from remote\n";
    print RDRIVER "\n";

    close( RDRIVER );

    system( "chmod a+rx $remote_driver_file" );
   }

#
# make a temporary subdirectory and go through the list of export pairs,
# making symbolic links and a directory structure that will be recrated on the 
# remote (execute) node
#
sub  prep_exports
   {
    my $tempdir = "tmpb1dir$$";

    mkdir( $tempdir ) || die "Can't mkdir $tempdir: $!\n";
    foreach my $p ( @_ )
       {
        prep_link( $tempdir, @{$p} );
       }

    # make the tarball for transfer.   'h' option follows the symlinks

    chdir( $tempdir );
    system( "tar hzcvf ../$prep_tarball ." );
    chdir( ".." );
   }


#
# handle the linking for one export pair.  A bit complicated because
# this handles globbing of multiple files and interprets ~ differently
# for the source and the target.
#
sub  prep_link
   {
    my $tempdir = shift;
    my $from = shift;
    my $to = shift;
    print "\n";
    print "prep_link '$from' to '$to'\n";
    my @from = prep_glob( $from );
    print "expanded from @from\n";
    unless ( $to )
       {
        if ( @from == 1 )
           { $to = $from[0]; }
        else
           { $to = '~'; }
       }
    # in the "to" directory, replace ~  or home with temp
    $to =~ s/^$ENV{'HOME'}/$tempdir/;
    $to =~ s/^~/$tempdir/;
    print "expanded to $to\n";
    my $to_path = dirname( $to );
    print "to_path is $to_path\n";   
    print "\n";

    # check that path exists, if not make it

    mkpath( $to_path ) unless ( -d $to_path );

    # create the symlink in the temporary directory.  Handle single
    # and multiple sources separately.

    if ( @from == 1 )
       {
        my $bf = basename( $from[0] );
        symlink( $from[0], $to_path . "/" . $bf );
       }
    else
       {
        mkpath( $to ) unless ( -d $to );
        foreach my $f ( @from )
           { symlink( $f, "$to/" . basename($f) ); }
       }
   }


#
# this changes any leading ~ to full the users home directory path and
# then performs a glob operation, return a list of files
#
sub  prep_glob
   {
    my $s = shift;
    $s =~ s/^~/$ENV{'HOME'}/;
    print "prep_glob [$s]\n";
    return( glob( $s ) );
   }


