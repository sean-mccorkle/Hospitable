#!/usr/bin/env perl
#
# adapting b1 for pbs on a shared filesystem
#

use strict;

use File::Basename;
use File::Path;
use Getopt::Std;
use Cwd;

#
# the command template is the full executable with all arguments, and
# $1, $2, ... are replaced by tuple values from the input stream.
# $$n means argument $n is a file and will need to be transfered to
# the remote host.
#
# this needs to be read in somehow!!!!
#

my $command_template = 'bowtie2 -k $3 -p 8 -x db/bn_trans -1 $$1 -2 $$2 -S k6test.sam';

#  These are filled by process_template()
my %arg_is_file;   # indicates which substitution args are files  ($$n)
my $max_arg = 0;   # maximum arg substituion number in template


                                 ################
                                 # Main Program #
                                 ################


process_template();   # figure out the argument and file situation

my $process_number = 0;

while ( <> )                 # for each input tuple
   {
    chomp;
    s/^\s+//;
    s/\s+$//;
    my @args = split( /\s+/ );

    my $user_cmd = expand_template( $command_template, @args );
    print "$user_cmd\n";
    write_job_file( "pbs_b1.$process_number.qsub", $user_cmd );

    $process_number++;
   }


print basename( $0 ), " ends.   $process_number processes.\n";


                                ###############
                                # Subroutines #
                                ###############

# this examines all the $n and $$n substitution args in the template $command_template 
# and determines the maximum arg number, returning that in the global $max_arg, and
# marking any $$n file args in the global hash %arg_is_file


sub  process_template
   {
    print "process_template [$command_template]\n";
    my @subst_matches = $command_template =~ /(\$\$?\d+)/g;
    print "subst_matches ", join( ",", @subst_matches ), "\n";
    foreach my $m ( @subst_matches )
       {
        $m =~ /\$(\$?)(\d+)/;
        my ( $fflag, $n ) = ( $1, $2 );
        $max_arg = $n if ( $n > $max_arg );
        $arg_is_file{$n} = 1 if ( $fflag ne '' );
       }
    print "max_arg is $max_arg\n";
    print "files are ", join( ",", sort { $a <=> $b } keys( %arg_is_file ) ), "\n";
   }

sub  expand_template
   {
    my ( $template, @args ) = @_;
    $template .= " ";   # to handle regexp at end of line
    foreach my $i ( 0..$#args )
       {
        my $j = $i+1;
        my $val = $args[$i];
        $template =~ s/(\$?\$$j)([^\d])/$val\2/g;
      }
    return( $template );
   }


sub  write_job_file
   {
    my ( $jfile, $user_command ) = @_;

    my $cwd = getcwd();
    open( JOB, ">$jfile" ) || die "can't write to $jfile: $!\n";
    print JOB <<EndOfJob;
#!/bin/tcsh
### Job name
#PBS -N $jfile
#PBS -k oe
### Queue name (small, medium, long, verylong)
#PBS -q hpc_compute
### Number of nodes (node property ev6 wanted)
#PBS -l nodes=1,walltime=30:00:00
### Declare job non-rerunable
##PBS -r n
### Output files
##PBS -e test.err   not sure why these 
##PBS -o test.log
### Mail to user
##PBS -m ae

# This job's working directory
echo Initial working directory is \$PBS_O_WORKDIR
cd $cwd

echo Running on host `hostname`
echo Time is `date`
echo Working directory is now `pwd`
set path = ( ~/src/bowtie2-2.2.5 \$path )
rehash
echo path is \$path

$user_command

echo Finished: `date`

EndOfJob
    close( JOB );
   }
